#version 400 core

in vec3 toCamera;
in vec3 lightDirection;

in vec4 lodAlpha_worldXZUndisplaced_oceanDepth;

out vec4 out_Color;

const vec3 _Diffuse = vec3(0, 2./255, 91./255);
const vec3 _DiffuseGrazing = vec3(51./255, 13./255, 13./255);

const vec3 _SubSurfaceColor = vec3(26./255,146./255, 134./255);
const float _SubSurfaceBase = 0.67;
const float _SubSurfaceSun = 5.25;
const float _SubSurfaceSunFallOff = 7.11;
//const vec3 _SubSurfaceCrestColor;

uniform sampler2DArray _AnimatedWaves;

const float _SliceIndex = 0;

vec2 LD_WorldToUV(vec2 i_samplePos, in vec2 i_centerPos, in float i_res, in float i_texelSize)
{
	return (i_samplePos - i_centerPos) / (i_texelSize * i_res) + 0.5;
}

vec3 WorldToUV(vec2 samplePos, in float sliceIndex) {
	vec2 result = LD_WorldToUV(
		samplePos,
		vec2(0, 0),
		512,
		0.125
	);
	return vec3(result, sliceIndex);
}

vec3 WorldToUV(vec2 samplePos) { return WorldToUV(samplePos, _SliceIndex); }

void SampleDisplacements(sampler2DArray dispSampler, vec3 uvSlice, float weight, inout vec3 worldPos, inout float sss) {
	vec4 data = texture(dispSampler, uvSlice, 0);
	worldPos += data.xyz * weight;
	sss += data.a * weight;
}

void SampleDisplacementsNormals(sampler2DArray dispSampler, vec3 uvSlice, float weight, float invRes, float texelSize, inout vec3 worldPos, inout vec2 nxz, inout float sss) {
	vec4 data = texture(dispSampler, uvSlice, 0);
	worldPos += data.xyz * weight;;
	sss += data.a * weight;
	vec3 disp = data.xyz;
	
	vec3 dd = vec3(invRes, 0.0, texelSize);
	vec3 disp_x = dd.zyy + texture(dispSampler, uvSlice + vec3(dd.xy, 0.0), dd.y).xyz;
	vec3 disp_z = dd.yyz + texture(dispSampler, uvSlice + vec3(dd.yx, 0.0), dd.y).xyz;
	vec3 n = normalize(cross(disp_z - disp, disp_x - disp)).xyz;
	
	nxz += n.xz * weight;
}

void main(void) {
	float v = abs(toCamera.y);
	
	vec3 uvSlice_smallerLod = WorldToUV(lodAlpha_worldXZUndisplaced_oceanDepth.yz);
	
	vec3 dummy = vec3(0, 0, 0);
	vec3 n_geom = vec3(0.0, 1.0, 0.0);
	float sss = 0;
	
	SampleDisplacementsNormals(_AnimatedWaves, uvSlice_smallerLod, 1.0, 0.0026, 0.1, dummy, n_geom.xz, sss);
	
	out_Color = vec4(mix(_Diffuse, _DiffuseGrazing, 1. - v), 1);
	
	// Approximate subsurface scattering
	float towardsSun = pow(max(0, dot(lightDirection, -toCamera)), _SubSurfaceSunFallOff);
	vec3 subsurface = (_SubSurfaceBase + _SubSurfaceSun * towardsSun) * _SubSurfaceColor.rgb; // * _LightColor0 * shadow
	
	//if !underwater
	subsurface *= (1 - v*v);
	
	//out_Color += vec4(subsurface, 0) * sss;
}